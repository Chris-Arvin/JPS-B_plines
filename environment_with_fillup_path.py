import create_map
import jps
import math
import numpy as np
import pure_B_spline
import matplotlib.pyplot as plt
import torch
import B_spline

# 这里的5个py文件思路如下：JPS生成控制点，进行点间填充，两点间的dx和dy均小于k；然后直接用B-spline
# 大多数时候，是擦线的。（这主要是因为jps控制点生成的不好的原因）


class env:
    def __init__(self, k=9, m=3):
        self.path = []     # global path
        self.map_class = None   # a class for map generation
        self.index = 0          # the index of the first point in local map
        self.current_state = None   # current state
        self.k = k      # max delta between two points
        self.m = m      # max movement distance
        self.len_x = 4*self.k + self.m      # x length of local map
        self.len_y = 4*self.k + self.m      # y length of local map
        self.action_space = 2              # 2x1 dimensions
        self.state_space = 24 + 5*2 + 2     # 36

    def reset(self):
        self.path = 'error'
        self.index = 0
        self.current_state = None   # current state
        # loop to generate a new map with a feasible path
        while self.path == 'error':
            # create map
            self.map_class = create_map.generate_map()
            # run JPS algorithm
            self.path = jps.run(self.map_class.get_start_node(), self.map_class.get_target_node(), self.map_class.get_map_size()[0],
                                self.map_class.get_map_size()[1], self.map_class.get_map())
        # print('generate a new map and path!')
        # print('path:', self.path)
        # print('-' * 30)

        # fill up the path
        index = 0
        while True:
            # print(index)
            if index >= len(self.path) - 1:
                break
            dx = int(np.ceil(abs(self.path[index + 1][0] - self.path[index][0])/self.k))
            dy = int(np.ceil(abs(self.path[index + 1][1] - self.path[index][1])/self.k))
            print(dx,dy)

            num = 0
            if dx>1 or dy>1:
                x_list = np.linspace(self.path[index][0],self.path[index+1][0],max(dx,dy)+1,endpoint=True)
                y_list = np.linspace(self.path[index][1],self.path[index+1][1],max(dx,dy)+1,endpoint=True)
                for i in range(len(x_list)-2,0,-1):
                    self.path.insert(index+1,[x_list[i],y_list[i]])
                num = len(x_list)-2
            print(num)
            index = index + 1 + num
        # interpolate for fourth B-spline.
        self.path.insert(0, self.path[0])
        self.path.insert(0, self.path[0])
        self.path.append(self.path[-1])
        self.path.append(self.path[-1])
        # print('filling up path finished!', self.path)
        # print('-'*30)

        # slide first time
        state, _ = self.slide()
        return self.flatten_state(state)

    def flatten_state(self,state):
        """
        flatten a state=[circle_dis, key_points, dx, dx] (24, 5*2, 1, 1) into a 1x36 formation
        :param state:
        :return:
        """
        flat_state = []
        for dis in state[0]:
            flat_state.append(dis)
        for pos in state[1]:
            flat_state.append(pos[0])
            flat_state.append(pos[1])
        flat_state.append(state[2])
        flat_state.append(state[3])
        return flat_state

    def extend_state(self,state):
        """
        extend a state:1x36 into [circle_dis, key_points, dx, dy]
        :param state:
        :return:
        """
        extend = []
        x1 = []
        x2 = []
        for i in range(24):
            x1.append(state[i])
        for i in range(24,34,2):
            x2.append([state[i],state[i+1]])
        extend.append(x1)
        extend.append(x2)
        extend.append(state[-2])
        extend.append(state[-1])
        return extend

    def step(self, action):
        """
        go forward into next state
        :param current_state: the state generated by self.slide() [circle, key_pos, dx, dy]
        :param action: the action generated by agent
        :return: next_state, reward, done, info
        """
        # initialize current_reward and done
        current_reward = 0      # the reward of current state and action
        done = 0                # whethe the agent finishs this episode
        info = ''

        # get changed key points
        action = [action[0][0].detach().numpy(),action[0][1].detach().numpy()]
        action_new = self.trans_action(action)  # get real action
        # print('current_action:',action_new)
        key_pos_old = self.current_state[1]          # get original local key points
        key_pos_new = key_pos_old               # get changed local key points
        key_pos_new[3] = [key_pos_old[3][0]+action_new[0], key_pos_old[3][1]+action_new[1]]
        _, local_map = self.slide()             # get original local map

        self.path[self.index+3] = [self.path[self.index+3][0]+action_new[0], self.path[self.index+3][1]+action_new[1]]   # change self.path by new action

        """
        Case1: new crooked_path collision
        """
        # check cllision for new crooked_path
        local_crooked_new = pure_B_spline.run(key_pos_new)
        is_collision = self.check_collision(local_map,local_crooked_new)       # attention, because index is not changed, this slide is same as the last one.
        if is_collision:
            current_reward = -3
            done = 1
            info = 'collision, new points'
            self.index = self.index + 1  # index++, slide index to next state
            next_state, _ = self.slide()    # 撞障碍物的话，按正常返回，给接下来的5个点
            return self.flatten_state(next_state), current_reward, done, info

        """
        Case2: successfully achieve the goal point
        """
        if self.index == len(self.path)-1-4:
            current_reward = 5
            done = 1
            info = 'success finish the game'
            next_state, _ = self.slide()    # 成功的话 next_state就返回调整后的当前5个点叭
            return self.flatten_state(next_state), current_reward, done, info

        """
        Case3: compare new crooked_path with the old one and the sate distance
        """
        # get old crooked_path
        local_crooked_old = pure_B_spline.run(key_pos_old)
        current_reward = self.get_reward(local_map, local_crooked_old, local_crooked_new)
        self.index = self.index + 1      # index++, slide index to next state
        next_state, next_local_map = self.slide()
        info = 'adjusted'
        done =0
        return self.flatten_state(next_state), current_reward, done, info


    def trans_action(self,action):
        """
        extend each action[i] with -1~1 into -3~3
        :param action: continuous action.
        :return: extended continuous action.
        """
        return [action[0]*3,action[1]*3]


    def slide(self):
        """
        get the state by index
        :param gridmap: the whole gridmap
        :param key_pos: all the key points
        :param k: the max delta between two original key points
        :param m: the max distance that fourth point can move
        :return current_state=[circle_detection, local_key_points, dx, dy]
        """
        self.key_pos = []
        for i in range(self.index,self.index+5):
            self.key_pos.append(self.path[i])
        local_map, local_key_pos, circle = self.cut_map_and_points(self.map_class.get_map(), self.key_pos, self.len_x, self.len_y)
        # print('size of local map: ',len(local_map),len(local_map[0]))
        # print('local key points: ',local_key_pos)
        # print('circle:',circle)
        # print('-'*30)
        self.current_state = [circle, local_key_pos, self.path[-1][0]-local_key_pos[-2][0], self.path[-1][1]-local_key_pos[-2][1]]
        return self.current_state, local_map



    def check_collision(self, gridmap, local_crooked_path):
        """
        :param gridmap:
        :param local_crooked_path:
        :return: return True, if collide with obstacles
        """
        for pos in local_crooked_path:
            if gridmap[int(round(pos[0]))][int(round(pos[1]))] == 1:
                return True
        return False

    def show_map(self, local_map=[], local_key_pos=[], circle=[]):
        """
        show the map
        """
        # set figure
        pic = plt.figure(figsize=[5,5])
        plt.axis('scaled')
        plt.xlim(-2,41)
        plt.ylim(-2,41)
        plt.grid()
        # show local map
        for x in range(len(local_map)):
            for y in range(len(local_map[0])):
                if local_map[x][y] == 1:
                    plt.scatter(x,y,color='black',marker='.')
        # show local key points
        for i in range(len(local_key_pos)):
            if i == 3:
                plt.scatter(local_key_pos[i][0],local_key_pos[i][1],color='purple', marker='o')
            else:
                plt.scatter(local_key_pos[i][0],local_key_pos[i][1],color='green', marker='o')
        # show circles
        for i in range(len(circle)):
            plt.scatter(local_key_pos[3][0]+circle[i]*math.cos(i*15/180*np.pi), local_key_pos[3][1]+circle[i]*math.sin(i*15/180*np.pi), color='red', marker='o')
        plt.show()



    def cut_map_and_points(self, gridmap,temp_key_pos,len_x,len_y):
        """
        cut the whole map into local map, find the key point and scan around the obstacles.
        :param gridmap: the whole map
        :param temp_key_pos: the local kei points
        :param len_x: x length of local map
        :param len_y: y length of local map
        :return: local_map, local_key_pos(in local map), circle(detect the around obstacles)
        """
        # initialize 4 borders
        left = 1000
        down = 1000
        right = -1
        top = -1
        # find four borders
        for pos in temp_key_pos:
            if pos[0] < left:
                left = pos[0]
            if pos[0] > right:
                right = pos[0]
            if pos[1] < down:
                down = pos[1]
            if pos[1] > top:
                top = pos[1]
        x_extend = int(len_x-(right-left))
        y_extend = int(len_y-(top-down))

        new_left = left - int(x_extend/2.0)
        new_right = right + int(x_extend-int(x_extend/2.0))     # prevention that the x_extend is odd number
        new_down = down - int(y_extend/2.0)
        new_top = top + int(y_extend-int(y_extend/2.0))         # prevention that the y_extend is odd number
        # prevention for overstep the boundary
        new_left = max(0, new_left)
        new_down = max(0, new_down)
        new_right = min(len(gridmap), new_right)
        new_top = min(len(gridmap[0]), new_top)
        # set local_map, that is, shift map
        local_map = np.ones([len_x,len_y])      # fill up for over region, such as overstep the boundary and so on.
        for x in range(0, int(new_right-new_left)):
            for y in range(0, int(new_top-new_down)):
                local_map[x][y]=gridmap[int(x+new_left)][int(y+new_down)]
        # set local key points, that is, shift key_pos
        local_key_pos=[]
        for pos in temp_key_pos:
            local_key_pos.append([pos[0]-new_left, pos[1]-new_down])
        # set circle obstacle detection
        fourth_pos=local_key_pos[3]
        circle=[]
        for i in range(0,360,15):
            x_new = fourth_pos[0]
            y_new = fourth_pos[1]
            dis = 0
            while x_new > 0 and x_new < len_x and y_new > 0 and y_new < len_y:
                if local_map[min(38,int(round(x_new)))][min(38,int(round(y_new)))] == 1:
                    break
                else:
                    x_new = x_new + math.cos(i*np.pi/180)
                    y_new = y_new + math.sin(i*np.pi/180)
                    dis = dis +1
            circle.append(dis)
        return local_map, local_key_pos, circle

    import numpy as np

    def get_reward(self, local_map, old_path, new_path, safe_dis=5.0):
        # calculate the distacne between the old path and the nearest obstacle
        min_dis_2 = 1000
        for x in range(len(local_map)):
            for y in range(len(local_map[0])):
                for pos in old_path:
                    if local_map[x][y] != 0:
                        dis_2 = (x - pos[0]) ** 2 + (y - pos[1]) ** 2
                        if dis_2 < min_dis_2:
                            min_dis_2 = dis_2
        min_dis_old = np.sqrt(min_dis_2)
        min_dis_old = max(0, min_dis_old - 0.5)  # for gridmap

        # calculate the distacne between the new path and the nearest obstacle
        min_dis_2 = 1000
        for x in range(len(local_map)):
            for y in range(len(local_map[0])):
                for pos in new_path:
                    if local_map[x][y] != 0:
                        dis_2 = (x - pos[0]) ** 2 + (y - pos[1]) ** 2
                        if dis_2 < min_dis_2:
                            min_dis_2 = dis_2
        min_dis_new = np.sqrt(min_dis_2)
        min_dis_new = max(0, min_dis_new - 0.5)

        """
        there are 3 cases：
        1. the distance between the new path and the nearest obstacle is more than safe distance, return 1, which is great
        2. even though the distance is not safe, but the new performance is better than the old one, return 0.5, acceptable
        3. the performance is worse than the old one, return -1, that's too bad.   
        """
        if min_dis_new > safe_dis:
            return 1
        elif min_dis_new >= min_dis_old:
            return 0.5
        else:
            return -1

if __name__ =='__main__':
    game = env()
    game.reset()

    x=[]
    y=[]
    for pos in game.path:
        x.append(pos[0])
        y.append(pos[1])

    x.pop(0)
    x.pop(0)
    x.pop(-1)
    x.pop(-1)
    y.pop(0)
    y.pop(0)
    y.pop(-1)
    y.pop(-1)
    crooked_x,crooked_y = B_spline.run(x,y)

    crooked_path=[]
    for i in range(len(crooked_y)):
        crooked_path.append([crooked_x[i],crooked_y[i]])
    game.map_class.show_map(game.path,crooked_path)